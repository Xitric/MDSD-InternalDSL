using System;
using InternalDSL.SemanticModel;
using InternalDSL.SemanticModel.Generator;

//I have opted for progressive interfaces to only expose legal methods to the
//client at any point in writing the DSL. For instance, methods for defining
//boolean comparisons only become visible after having specified the function
//under test in a property.
namespace InternalDSL.Builder
{
    /// <summary>
    /// Interface for objects used to construct tests with a specific input
    /// type.
    /// </summary>
    public interface IFluentTestBuilder
    {
        /// <summary>
        /// Specify the number of samples to be generated when running this
        /// test. A sample is a random value generated by the input generator.
        /// </summary>
        /// <param name="samples">The number of samples, must be greater than 0</param>
        /// <returns>The progressive builder</returns>
        IFluentTestBuilder Samples(int samples);

        /// <summary>
        /// Specify which input generator to use for all properties of this
        /// test. The generator will be sampled to determine which input to
        /// pass to the function under test.
        /// </summary>
        /// <param name="generator">The generator from which to sample input values for the function under test</param>
        /// <returns>The progressive builder</returns>
        IFluentTestBuilder<TInput> Generator<TInput>(Generator<TInput> generator);
    }

    /// <summary>
    /// Interface for objects used to construct tests with a variable number of
    /// properties.
    /// </summary>
    public interface IFluentTestBuilder<TInput>
    {
        /// <summary>
        /// Start building a new property. The property is finished when a new
        /// property is begun or when calling the Build() function.
        /// </summary>
        /// <param name="description">A human-readable description of the property to be printed in case it fails</param>
        /// <returns>The progressive builder</returns>
        IFluentPropertyBuilder<TInput> Property(string description);

        /// <summary>
        /// Complete the building of this test and retrieve the resulting Test
        /// object.
        /// </summary>
        /// <returns>The resulting test ready to be executed</returns>
        ITest<TInput> Build();
    }

    /// <summary>
    /// Interface for objects used to configure a property with optional
    /// preconditions and a function under test.
    /// </summary>
    public interface IFluentPropertyBuilder<TInput>
    {
        /// <summary>
        /// Specify a pre-condition to hold for the input to the function under
        /// test. The function will only be presented with input that passes
        /// this pre-condition. It is possible to provide multiple predicates
        /// if one desires. In this case, all predicates must pass.
        /// </summary>
        /// <param name="function">A predicate for evaluating input values against the pre-condition</param>
        /// <returns>The progressive builder</returns>
        IFluentPropertyBuilder<TInput> Given(Func<TInput, bool> function);

        /// <summary>
        /// Specify the function under test. This function will be called with
        /// sampled input values from the generator, and its output will be
        /// compared against the post-conditions of the property.
        /// </summary>
        /// <param name="function">The function under test</param>
        /// <returns>The progressive builder</returns>
        IFluentComparisonBuilder<TInput, TOutput> Then<TOutput>(Func<TInput, TOutput> function)
            where TOutput : class;

        /// <summary>
        /// Specify the function under test. This function will be called with
        /// sampled input values from the generator, and its output will be
        /// compared against the post-conditions of the property. This method
        /// will return a special builder that uses nested lambda expressions
        /// for creating boolean comparisons of the function output.
        /// </summary>
        /// <param name="function">The function under test</param>
        /// <returns>The progressive builder that uses nested lambda expressions</returns>
        IFluentComparisonLambdaBuilder<TInput, TOutput> ThenLambda<TOutput>(Func<TInput, TOutput> function)
            where TOutput : class;
    }

    /// <summary>
    /// Interface for objects used to specify the conditions that must be met
    /// for a property to be satisfied.
    /// </summary>
    /// <typeparam name="TInput">The type of input given to the function under test</typeparam>
    /// <typeparam name="TOutput">The return type of the function under test</typeparam>
    public interface IFluentComparisonBuilder<TInput, TOutput>
    {
        /// <summary>
        /// Add a new comparison to the end of this builder. It can be argued
        /// if this method should be available on the interface. I argue that
        /// it is useful, because it allows for clients to define their own
        /// comparison types and use them together with this interface through
        /// extension methods. Thus, clients can extend the builder without
        /// creating their own subtypes. Specifically, this is used in the
        /// class ComparisonBuilderExtensionMethods.
        /// </summary>
        /// <param name="comparison">The comparison object to add</param>
        /// <returns>The progressive builder</returns>
        IFluentComparisonCombinationBuilder<TInput, TOutput> AppendComparison(IComparison comparison);

        /// <summary>
        /// Add a comparison of the function output against a literal value.
        /// </summary>
        /// <param name="literal">The literal value to compare against</param>
        /// <returns>The progressive builder</returns>
        IFluentComparisonCombinationBuilder<TInput, TOutput> Equals(TOutput literal);

        /// <summary>
        /// Add a comparison of the function output against that of another
        /// function.
        /// </summary>
        /// <param name="function">The function whose output to compare against</param>
        /// <returns>The progressive builder</returns>
        IFluentComparisonCombinationBuilder<TInput, TOutput> Equals(Func<TInput, TOutput> function);

        /// <summary>
        /// Add a comparison that checks if the output of the function is not
        /// equal to the given literal value.
        /// </summary>
        /// <param name="literal">The literal value to compare against</param>
        /// <returns>The progressive builder</returns>
        IFluentComparisonCombinationBuilder<TInput, TOutput> IsNotEqual(TOutput literal);

        /// <summary>
        /// Add a comparison that checks if the output of the function is not
        /// equal to that of another function.
        /// </summary>
        /// <param name="function">The function whose output to compare against</param>
        /// <returns>The progressive builder</returns>
        IFluentComparisonCombinationBuilder<TInput, TOutput> IsNotEqual(Func<TInput, TOutput> function);

        /// <summary>
        /// Begin a new block of comparisons. A block is similar to using
        /// parentheses and it affects the order in which comparisons are
        /// evaluated and ho they are affected by the boolean operators.
        /// </summary>
        /// <returns>The progressive builder</returns>
        IFluentComparisonBuilder<TInput, TOutput> BeginBlock();
    }

    /// <summary>
    /// Interface for objects used to combine multiple conditions into compound
    /// boolean conditions that must be met for a property to be satisfied.
    /// </summary>
    public interface IFluentComparisonCombinationBuilder<TInput, TOutput> : IFluentTestBuilder<TInput>
    {
        /// <summary>
        /// Combine the previous comparison with another one using the boolean
        /// And operator.
        /// </summary>
        /// <returns>The progressive builder</returns>
        IFluentComparisonBuilder<TInput, TOutput> And();

        /// <summary>
        /// Combine the previous comparison with another one using the boolean
        /// Or operator.
        /// </summary>
        /// <returns>The progressive builder</returns>
        IFluentComparisonBuilder<TInput, TOutput> Or();

        /// <summary>
        /// Finish the current block of comparisons. This is similar to adding
        /// a closing parenthesis in a boolean expression.
        /// </summary>
        /// <returns>The progressive builder</returns>
        IFluentComparisonCombinationBuilder<TInput, TOutput> EndBlock();
    }

    /// <summary>
    /// Interface for objects used to construct boolean expressions using
    /// nested lambdas.
    /// </summary>
    public interface IFluentComparisonLambdaBuilder<TInput, in TOutput>
    {
        /// <summary>
        /// Specify the boolean expression that must be satisfied for this
        /// property to hold.
        /// </summary>
        /// <param name="comparisonBuilder">Lambda expression for building the boolean expression</param>
        /// <returns>The progressive builder</returns>
        IFluentTestBuilder<TInput> Satisfies(Func<IFluentComparisonLambdaBuilder<TInput, TOutput>, IComparison> comparisonBuilder);

        /// <summary>
        /// Add a comparison of the function output against a literal value.
        /// </summary>
        /// <param name="literal">The literal value to compare against</param>
        /// <returns>The resulting boolean expression</returns>
        IComparison Equals(TOutput literal);

        /// <summary>
        /// Add a comparison of the function output against that of another
        /// function.
        /// </summary>
        /// <param name="function">The function whose output to compare against</param>
        /// <returns>The resulting boolean expression</returns>
        IComparison Equals(Func<TInput, TOutput> function);

        /// <summary>
        /// Add a comparison that checks if the output of the function is not
        /// equal to the given literal value.
        /// </summary>
        /// <param name="literal">The literal value to compare against</param>
        /// <returns>The resulting boolean expression</returns>
        IComparison IsNotEqual(TOutput literal);

        /// <summary>
        /// Add a comparison that checks if the output of the function is not
        /// equal to that of another function.
        /// </summary>
        /// <param name="function">The function whose output to compare against</param>
        /// <returns>The resulting boolean expression</returns>
        IComparison IsNotEqual(Func<TInput, TOutput> function);

        /// <summary>
        /// Combine two boolean expressions with the logical And operator.
        /// </summary>
        /// <param name="left">The boolean expression to the left of the operator</param>
        /// <param name="right">The boolean expression to the right of the operator</param>
        /// <returns>The resulting boolean expression</returns>
        IComparison And(
            Func<IFluentComparisonLambdaBuilder<TInput, TOutput>, IComparison> left,
            Func<IFluentComparisonLambdaBuilder<TInput, TOutput>, IComparison> right);

        /// <summary>
        /// Combine two boolean expressions with the logical Or operator.
        /// </summary>
        /// <param name="left">The boolean expression to the left of the operator</param>
        /// <param name="right">The boolean expression to the right of the operator</param>
        /// <returns>The resulting boolean expression</returns>
        IComparison Or(
            Func<IFluentComparisonLambdaBuilder<TInput, TOutput>, IComparison> left,
            Func<IFluentComparisonLambdaBuilder<TInput, TOutput>, IComparison> right);
    }
}

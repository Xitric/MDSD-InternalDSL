using System;
using System.Collections.Generic;
using System.Linq;
using InternalDSL.SemanticModel;
using InternalDSL.SemanticModel.Generator;

//I have opted for progressive interfaces to only expose legal methods to the
//client at any point in writing the DSL. For instance, methods for defining
//boolean comparisons only become visible after having specified the function
//under test in a property.
namespace InternalDSL.Builder
{
    /// <summary>
    /// Interface for objects used to construct tests with a specific input
    /// type.
    /// </summary>
    public interface IFluentTestBuilder
    {
        /// <summary>
        /// Specify the number of samples to be generated when running this
        /// test. A sample is a random value generated by the input generator.
        /// </summary>
        /// <param name="samples">The number of samples, must be greater than 0</param>
        /// <returns>The progressive builder</returns>
        IFluentTestBuilder Samples(int samples);

        /// <summary>
        /// Specify which input generator to use for all properties of this
        /// test. The generator will be sampled to determine which input to
        /// pass to the function under test.
        /// </summary>
        /// <typeparam name="TInput">The type of input given to the function under test</typeparam>
        /// <param name="generator">The generator from which to sample input values for the function under test</param>
        /// <returns>The progressive builder</returns>
        IFluentTestBuilder<TInput> Generator<TInput>(Generator<TInput> generator);
    }

    /// <summary>
    /// Interface for objects used to construct tests with a variable number of
    /// properties.
    /// </summary>
    /// <typeparam name="TInput">The type of input given to the function under test</typeparam>
    public interface IFluentTestBuilder<TInput>
    {
        /// <summary>
        /// Start building a new property. The property is finished when a new
        /// property is begun or when calling the Build() function.
        /// </summary>
        /// <param name="description">A human-readable description of the property to be printed in case it fails</param>
        /// <returns>The progressive builder</returns>
        IFluentPropertyBuilder<TInput> Property(string description);

        /// <summary>
        /// Complete the building of this test and retrieve the resulting Test
        /// object.
        /// </summary>
        /// <returns>The resulting test ready to be executed</returns>
        Test<TInput> Build();
    }

    /// <summary>
    /// Interface for objects used to configure a property with optional
    /// preconditions and a function under test.
    /// </summary>
    /// <typeparam name="TInput">The type of input given to the function under test</typeparam>
    public interface IFluentPropertyBuilder<TInput>
    {
        /// <summary>
        /// Specify a pre-condition to hold for the input to the function under
        /// test. The function will only be presented with input that passes
        /// this pre-condition. It is possible to provide multiple predicates
        /// if one desires. In this case, all predicates must pass.
        /// </summary>
        /// <param name="function">A predicate for evaluating input values against the pre-condition</param>
        /// <returns>The progressive builder</returns>
        IFluentPropertyBuilder<TInput> Given(Func<TInput, bool> function);

        /// <summary>
        /// Specify the function under test. This function will be called with
        /// sampled input values from the generator, and its output will be
        /// compared against the post-conditions of the property.
        /// </summary>
        /// <typeparam name="TOutput">The return type of the function under test</typeparam>
        /// <param name="function">The function under test</param>
        /// <returns>The progressive builder</returns>
        IFluentComparisonBuilder<TInput, TOutput> Then<TOutput>(Func<TInput, TOutput> function)
            where TOutput : class;

        /// <summary>
        /// Specify the function under test. This function will be called with
        /// sampled input values from the generator, and its output will be
        /// compared against the post-conditions of the property. This method
        /// will return a special builder that uses nested lambda expressions
        /// for creating boolean comparisons of the function output.
        /// </summary>
        /// <typeparam name="TOutput">The return type of the function under test</typeparam>
        /// <param name="function">The function under test</param>
        /// <returns>The progressive builder that uses nested lambda expressions</returns>
        IFluentComparisonLambdaBuilder<TInput, TOutput> ThenLambda<TOutput>(Func<TInput, TOutput> function)
            where TOutput : class;
    }

    /// <summary>
    /// Interface for objects used to specify the conditions that must be met
    /// for a property to be satisfied.
    /// </summary>
    /// <typeparam name="TInput">The type of input given to the function under test</typeparam>
    /// <typeparam name="TOutput">The return type of the function under test</typeparam>
    public interface IFluentComparisonBuilder<TInput, TOutput>
    {
        /// <summary>
        /// Add a new comparison to the end of this builder. It can be argued
        /// if this method should be available on the interface. I argue that
        /// it is useful, because it allows for clients to define their own
        /// comparison types and use them together with this interface through
        /// extension methods. Thus, clients can extend the builder without
        /// creating their own subtypes. Specifically, this is used in the
        /// class ComparisonBuilderExtensionMethods.
        /// </summary>
        /// <param name="comparison">The comparison object to add</param>
        /// <returns>The progressive builder</returns>
        IFluentComparisonCombinationBuilder<TInput, TOutput> AppendComparison(IComparison comparison);

        /// <summary>
        /// Add a comparison of the function output against a literal value.
        /// </summary>
        /// <param name="literal">The literal value to compare against</param>
        /// <returns>The progressive builder</returns>
        IFluentComparisonCombinationBuilder<TInput, TOutput> Equals(TOutput literal);

        /// <summary>
        /// Add a comparison of the function output against that of another
        /// function.
        /// </summary>
        /// <param name="function">The function whose output to compare against</param>
        /// <returns>The progressive builder</returns>
        IFluentComparisonCombinationBuilder<TInput, TOutput> Equals(Func<TInput, TOutput> function);

        /// <summary>
        /// Add a comparison that checks if the output of the function is not
        /// equal to the given literal value.
        /// </summary>
        /// <param name="literal">The literal value to compare against</param>
        /// <returns>The progressive builder</returns>
        IFluentComparisonCombinationBuilder<TInput, TOutput> IsNotEqual(TOutput literal);

        /// <summary>
        /// Add a comparison that checks if the output of the function is not
        /// equal to that of another function.
        /// </summary>
        /// <param name="function">The function whose output to compare against</param>
        /// <returns>The progressive builder</returns>
        IFluentComparisonCombinationBuilder<TInput, TOutput> IsNotEqual(Func<TInput, TOutput> function);

        /// <summary>
        /// Begin a new block of comparisons. A block is similar to using
        /// parentheses and it affects the order in which comparisons are
        /// evaluated and ho they are affected by the boolean operators.
        /// </summary>
        /// <returns>The progressive builder</returns>
        IFluentComparisonBuilder<TInput, TOutput> BeginBlock();
    }

    /// <summary>
    /// Interface for objects used to combine multiple conditions into compound
    /// boolean conditions that must be met for a property to be satisfied.
    /// </summary>
    /// <typeparam name="TInput">The type of input given to the function under test</typeparam>
    /// <typeparam name="TOutput">The return type of the function under test</typeparam>
    public interface IFluentComparisonCombinationBuilder<TInput, TOutput> : IFluentTestBuilder<TInput>
    {
        /// <summary>
        /// Combine the previous comparison with another one using the boolean
        /// And operator.
        /// </summary>
        /// <returns>The progressive builder</returns>
        IFluentComparisonBuilder<TInput, TOutput> And();

        /// <summary>
        /// Combine the previous comparison with another one using the boolean
        /// Or operator.
        /// </summary>
        /// <returns>The progressive builder</returns>
        IFluentComparisonBuilder<TInput, TOutput> Or();

        /// <summary>
        /// Finish the current block of comparisons. This is similar to adding
        /// a closing parenthesis in a boolean expression.
        /// </summary>
        /// <returns>The progressive builder</returns>
        IFluentComparisonCombinationBuilder<TInput, TOutput> EndBlock();
    }

    public interface IFluentComparisonLambdaBuilder<TInput, TOutput>
    {
        IFluentTestBuilder<TInput> Satisfies(Func<IFluentComparisonLambdaBuilder<TInput, TOutput>, IComparison> comparisonBuilder);

        IComparison Equals(TOutput literal);
        IComparison Equals(Func<TInput, TOutput> function);

        IComparison IsNotEqual(TOutput literal);
        IComparison IsNotEqual(Func<TInput, TOutput> function);

        IComparison And(
            Func<IFluentComparisonLambdaBuilder<TInput, TOutput>, IComparison> left,
            Func<IFluentComparisonLambdaBuilder<TInput, TOutput>, IComparison> right);
        IComparison Or(
            Func<IFluentComparisonLambdaBuilder<TInput, TOutput>, IComparison> left,
            Func<IFluentComparisonLambdaBuilder<TInput, TOutput>, IComparison> right);
    }

    public class FluentTestBuilder : IFluentTestBuilder
    {
        protected string Name { get; set; }
        protected int SampleCount { get; set; } = 100;

        /// <summary>
        /// Begin the chain for building a new test. Usually this method will
        /// be available through static importing.
        /// </summary>
        /// <param name="name">The name of the test, used for referring to it and for printing if the test fails</param>
        /// <returns>The progressive builder</returns>
        public static FluentTestBuilder Test(string name)
        {
            return new FluentTestBuilder() { Name = name };
        }

        public IFluentTestBuilder Samples(int samples)
        {
            SampleCount = samples;
            return this;
        }

        public IFluentTestBuilder<TInput> Generator<TInput>(Generator<TInput> generator)
        {
            return new FluentTestBuilder<TInput>()
            {
                Name = Name,
                SampleCount = SampleCount,
                Generator = generator,
                SemanticModel = new Test<TInput>(Name, SampleCount, generator)
            };
        }
    }

    internal class FluentTestBuilder<TInput> : FluentTestBuilder, IFluentTestBuilder<TInput>, IFluentPropertyBuilder<TInput>
    {
        internal Generator<TInput> Generator { get; set; }
        protected string Description;
        protected IList<Func<TInput, bool>> Preconditions;
        internal Test<TInput> SemanticModel { get; set; }

        public virtual IFluentPropertyBuilder<TInput> Property(string description)
        {
            Preconditions = null;
            Description = description;
            return this;
        }

        public virtual Test<TInput> Build()
        {
            return SemanticModel;
        }

        public IFluentPropertyBuilder<TInput> Given(Func<TInput, bool> function)
        {
            if (Preconditions == null)
            {
                Preconditions = new List<Func<TInput, bool>>();
            }

            Preconditions.Add(function);
            return this;
        }

        public IFluentComparisonBuilder<TInput, TOutput> Then<TOutput>(Func<TInput, TOutput> function)
            where TOutput : class
        {
            //"Upgrade" to a builder that now also knows the output type
            return new FluentTestBuilder<TInput, TOutput>()
            {
                Name = Name,
                SampleCount = SampleCount,
                Generator = Generator,
                SemanticModel = SemanticModel,
                Description = Description,
                Preconditions = Preconditions,
                Function = function
            };
        }

        public IFluentComparisonLambdaBuilder<TInput, TOutput> ThenLambda<TOutput>(Func<TInput, TOutput> function)
            where TOutput : class
        {
            //"Upgrade" to a builder that now also knows the output type and uses lambdas
            return new FluentTestLambdaBuilder<TInput, TOutput>()
            {
                Name = Name,
                SampleCount = SampleCount,
                Generator = Generator,
                SemanticModel = SemanticModel,
                Description = Description,
                Preconditions = Preconditions,
                Function = function
            };
        }
    }

    internal class FluentTestBuilder<TInput, TOutput> : FluentTestBuilder<TInput>,
        IFluentComparisonBuilder<TInput, TOutput>, IFluentComparisonCombinationBuilder<TInput, TOutput> where TOutput : class
    {
        internal Func<TInput, TOutput> Function;
        private readonly Stack<IComparison> _ongoingComparisons = new Stack<IComparison>();
        private readonly Stack<BooleanOperator> _ongoingOperators = new Stack<BooleanOperator>();
        private bool _shouldPush;
        private int _nestDepth;

        public IFluentComparisonCombinationBuilder<TInput, TOutput> AppendComparison(
            IComparison comparison)
        {
            if (_shouldPush || !_ongoingComparisons.Any())
            {
                _ongoingComparisons.Push(comparison);
                _shouldPush = false;
            }
            else
            {
                var currentComparison = _ongoingComparisons.Pop();
                var op = _ongoingOperators.Pop(); //TODO: Ensure correct number of operators on stack
                var newComparison = new BlockComparison(currentComparison, comparison, op);
                _ongoingComparisons.Push(newComparison);
            }
            
            return this;
        }

        public IFluentComparisonCombinationBuilder<TInput, TOutput> Equals(TOutput literal) =>
            AppendComparison(new LiteralEqualityComparison<TInput>(literal));

        public IFluentComparisonCombinationBuilder<TInput, TOutput> Equals(Func<TInput, TOutput> function) =>
            AppendComparison(new FunctionEqualityComparison<TInput>(function));

        public IFluentComparisonCombinationBuilder<TInput, TOutput> IsNotEqual(TOutput literal) =>
            AppendComparison(new LiteralEqualityComparison<TInput>(literal, false));

        public IFluentComparisonCombinationBuilder<TInput, TOutput> IsNotEqual(Func<TInput, TOutput> function) =>
            AppendComparison(new FunctionEqualityComparison<TInput>(function, false));

        public IFluentComparisonBuilder<TInput, TOutput> And()
        {
            _ongoingOperators.Push(BooleanOperator.And);
            return this;
        }

        public IFluentComparisonBuilder<TInput, TOutput> Or()
        {
            _ongoingOperators.Push(BooleanOperator.Or);
            return this;
        }

        public IFluentComparisonBuilder<TInput, TOutput> BeginBlock()
        {
            _nestDepth++;
            _shouldPush = true;
            return this;
        }

        public IFluentComparisonCombinationBuilder<TInput, TOutput> EndBlock()
        {
            if (_ongoingComparisons.Count > _nestDepth)
            {
                var right = _ongoingComparisons.Pop();
                var left = _ongoingComparisons.Pop();
                var op = _ongoingOperators.Pop();
                //TODO: Something with ensuring both stacks have similar heights (operator stack 1 smaller)

                var newComparison = new BlockComparison(left, right, op);

                _ongoingComparisons.Push(newComparison);
            }

            _nestDepth--;
            return this;
        }

        public override IFluentPropertyBuilder<TInput> Property(string description)
        {
            FlushProperty();
            return base.Property(description);
        }

        public override Test<TInput> Build()
        {
            FlushProperty();
            return base.Build();
        }

        private void FlushProperty()
        {
            if (Description == null)
            {
                throw new InvalidOperationException("Missing description for new property");
            }

            if (Function == null)
            {
                throw new InvalidOperationException("Missing test function for new property");
            }

            if (!_ongoingComparisons.Any())
            {
                throw new InvalidOperationException("Missing comparison for new property");
            }

            if (_ongoingComparisons.Count > 1)
            {
                throw new InvalidOperationException("Unfinished comparison for new property");
            }

            var property = new Property<TInput, TOutput>(Description, Function, _ongoingComparisons.Pop());
            SemanticModel.AddProperty(property);
        }
    }

    internal class FluentTestLambdaBuilder<TInput, TOutput> : FluentTestBuilder<TInput>,
        IFluentComparisonLambdaBuilder<TInput, TOutput> where TOutput : class
    {
        internal Func<TInput, TOutput> Function;

        public IFluentTestBuilder<TInput> Satisfies(Func<IFluentComparisonLambdaBuilder<TInput, TOutput>, IComparison> comparisonBuilder)
        {
            var comparison = comparisonBuilder(this);
            var property = new Property<TInput, TOutput>(Description, Function, comparison);
            SemanticModel.AddProperty(property);
            return this;
        }

        public IComparison Equals(TOutput literal)
        {
            return new LiteralEqualityComparison<TInput>(literal);
        }

        public IComparison Equals(Func<TInput, TOutput> function)
        {
            return new FunctionEqualityComparison<TInput>(function);
        }

        public IComparison IsNotEqual(TOutput literal)
        {
            return new LiteralEqualityComparison<TInput>(literal, false);
        }

        public IComparison IsNotEqual(Func<TInput, TOutput> function)
        {
            return new FunctionEqualityComparison<TInput>(function, false);
        }

        public IComparison And(
            Func<IFluentComparisonLambdaBuilder<TInput, TOutput>, IComparison> left,
            Func<IFluentComparisonLambdaBuilder<TInput, TOutput>, IComparison> right)
        {
            var leftComparison = left(this);
            var rightComparison = right(this);

            return new BlockComparison(leftComparison, rightComparison, BooleanOperator.And);
        }

        public IComparison Or(
            Func<IFluentComparisonLambdaBuilder<TInput, TOutput>, IComparison> left,
            Func<IFluentComparisonLambdaBuilder<TInput, TOutput>, IComparison> right)
        {
            var leftComparison = left(this);
            var rightComparison = right(this);

            return new BlockComparison(leftComparison, rightComparison, BooleanOperator.Or);
        }
    }

    /// <summary>
    /// Extensions methods for the IFluentComparisonBuilder when its output
    /// type is comparable, thus allowing for additional checks.
    /// </summary>
    public static class ComparisonBuilderExtensionMethods
    {
        /// <summary>
        /// Check if the output of the function under test is greater than the
        /// specified literal value.
        /// </summary>
        /// <typeparam name="TInput">The type of input given to the function under test</typeparam>
        /// <typeparam name="TOutput">The return type of the function under test</typeparam>
        /// <param name="self">The progressive builder</param>
        /// <param name="literal">The literal value to compare against</param>
        /// <returns>The progressive builder</returns>
        public static IFluentComparisonCombinationBuilder<TInput, TOutput> IsGreaterThan<TInput, TOutput>(
            this IFluentComparisonBuilder<TInput, TOutput> self, TOutput literal)
            where TOutput : IComparable<TOutput>
        {
            return self.AppendComparison(new LiteralComparison<TInput>(literal, EqualityOperator.GreaterThan));
        }

        /// <summary>
        /// Check if the output of the function under test is greater than the
        /// output of another function.
        /// </summary>
        /// <typeparam name="TInput">The type of input given to the function under test</typeparam>
        /// <typeparam name="TOutput">The return type of the function under test</typeparam>
        /// <param name="self">The progressive builder</param>
        /// <param name="function">The function whose output to compare against</param>
        /// <returns>The progressive builder</returns>
        public static IFluentComparisonCombinationBuilder<TInput, TOutput> IsGreaterThan<TInput, TOutput>(
            this IFluentComparisonBuilder<TInput, TOutput> self, Func<TInput, dynamic> function)
            where TOutput : IComparable<TOutput>
        {
            return self.AppendComparison(new FunctionComparison<TInput>(function, EqualityOperator.GreaterThan));
        }

        /// <summary>
        /// Check if the output of the function under test is less than the
        /// specified literal value.
        /// </summary>
        /// <typeparam name="TInput">The type of input given to the function under test</typeparam>
        /// <typeparam name="TOutput">The return type of the function under test</typeparam>
        /// <param name="self">The progressive builder</param>
        /// <param name="literal">The literal value to compare against</param>
        /// <returns>The progressive builder</returns>
        public static IFluentComparisonCombinationBuilder<TInput, TOutput> IsLessThan<TInput, TOutput>(
            this IFluentComparisonBuilder<TInput, TOutput> self, TOutput literal)
            where TOutput : IComparable<TOutput>
        {
            return self.AppendComparison(new LiteralComparison<TInput>(literal, EqualityOperator.LessThan));
        }

        /// <summary>
        /// Check if the output of the function under test is less than the
        /// output of another function.
        /// </summary>
        /// <typeparam name="TInput">The type of input given to the function under test</typeparam>
        /// <typeparam name="TOutput">The return type of the function under test</typeparam>
        /// <param name="self">The progressive builder</param>
        /// <param name="function">The function whose output to compare against</param>
        /// <returns>The progressive builder</returns>
        public static IFluentComparisonCombinationBuilder<TInput, TOutput> IsLessThan<TInput, TOutput>(
            this IFluentComparisonBuilder<TInput, TOutput> self, Func<TInput, dynamic> function)
            where TOutput : IComparable<TOutput>
        {
            return self.AppendComparison(new FunctionComparison<TInput>(function, EqualityOperator.LessThan));
        }
    }
}
